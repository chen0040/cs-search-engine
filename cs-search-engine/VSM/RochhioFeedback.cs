using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace SearchEngine.VSM
{
    /// <summary>
    /// Rochhio feedback tries to move the query vector closer to the user-identied relevant docs (e.g., by clicking the doc retrieved using the same query) and away from the user-identified irrelevant docs (e.g. by not clicking the doc retrieved using the same query)
    /// Rochhio feedback is used for vector space model to help return docs better matched the user's search behavior
    /// </summary>
    public class RochhioFeedback : IFeedback
    {
        protected double mAlpha; // discount factor for the original query vector entry
        protected double mBeta; //discount factor for the relevant doc query vector centroid entry
        protected double mGamma; //discount factor for the irrelevant doc query vector centroid entry
        protected ITokenizer mQuery;

        public ITokenizer OriginalQuery
        {
            get { return mQuery; }
        }

        protected Dictionary<string, double> mQueryVector;

        public Dictionary<string, double> ModifiedQueryVector
        {
            get
            {
                return mQueryVector;
            }
        }

        private static string[] GetTokenUnion(ITokenizer query, ITokenizer[] relevant_docs, ITokenizer[] irrelevant_docs)
        {
            HashSet<string> word_union_set = new HashSet<string>();
            foreach (string word in query.Tokens)
            {
                word_union_set.Add(word);
            }

            foreach (ITokenizer t in relevant_docs)
            {
                foreach (string word in t.Tokens)
                {
                    word_union_set.Add(word);
                }
            }

            foreach (ITokenizer t in irrelevant_docs)
            {
                foreach (string word in t.Tokens)
                {
                    word_union_set.Add(word);
                }
            }

            return word_union_set.ToArray();
        }

        public RochhioFeedback(double alpha, double beta, double gamma)
        {
            mAlpha = alpha;
            mBeta = beta;
            mGamma = gamma;

           
        }

        /// <summary>
        /// Implicit feedback can be generated by recognizing user clicking some retrieved docs (relevant) and not the other retrieved docs (irrelevant) of the query
        /// </summary>
        /// <param name="query"></param>
        /// <param name="relevant_docs"></param>
        /// <param name="irrelevant_docs"></param>
        /// <returns></returns>
        public Dictionary<string, double> BuildFromImplicitFeedback(ITokenizer query, ITokenizer[] relevant_docs, ITokenizer[] irrelevant_docs)
        {
            mQuery = query;

            string[] tokens = GetTokenUnion(query, relevant_docs, irrelevant_docs);
            int queryLen = query.Tokens.Length;

            Dictionary<string, double> query_vector = new Dictionary<string, double>();
            Dictionary<string, double> irrelevant_doc_centroid = new Dictionary<string, double>();
            Dictionary<string, double> relevant_doc_centroid = new Dictionary<string, double>();
            for (int k = 0; k < queryLen; ++k)
            {
                string term = tokens[k];
                if (query_vector.ContainsKey(term))
                {
                    query_vector[term] += 1;
                }
                else
                {
                    query_vector[term] = 1;
                }
            }
            foreach (ITokenizer t in relevant_docs)
            {
                foreach (string term in t.Tokens)
                {
                    if (relevant_doc_centroid.ContainsKey(term))
                    {
                        relevant_doc_centroid[term] += 1;
                    }
                    else
                    {
                        relevant_doc_centroid[term] = 1;
                    }
                }
            }
            foreach (ITokenizer t in irrelevant_docs)
            {
                foreach (string term in t.Tokens)
                {
                    if (irrelevant_doc_centroid.ContainsKey(term))
                    {
                        irrelevant_doc_centroid[term] += 1;
                    }
                    else
                    {
                        irrelevant_doc_centroid[term] = 1;
                    }
                }
            }

            int n = query_vector.Count;
            foreach (string term in query_vector.Keys)
            {
                relevant_doc_centroid[term] /= n;
                irrelevant_doc_centroid[term] /= n;
            }

            mQueryVector = new Dictionary<string, double>();

            double rav = relevant_doc_centroid.Values.Average();
            double rsigma = 0;
            foreach (string term in relevant_doc_centroid.Keys)
            {
                rsigma += System.Math.Pow(relevant_doc_centroid[term] - rav, 2);
            }
            
            rsigma = System.Math.Sqrt(rsigma / n);
            double z_critical = 2; // 95% confidence is roughly 2 * SE (SE is the standard deviation)

            foreach(string term in query_vector.Keys)
            {
                double q = query_vector[term];
                double r = relevant_doc_centroid[term];
                double ir = irrelevant_doc_centroid[term];

                double q_pi = mAlpha * q + mBeta * r - mGamma * ir;
                if (q > 0)
                {
                    q_pi = System.Math.Min(q, q_pi);
                    mQueryVector[term] = q_pi;
                }
                else if(r >= rav + z_critical * rsigma / n)
                {
                    mQueryVector[term] = q_pi;
                }
            }

            return mQueryVector;
        }
    }
}
